package int160_test

import (
	"crypto/rand"
	"testing"

	"github.com/james-lawrence/torrent/dht/int160"

	"github.com/stretchr/testify/require"
)

func TestInt160(t *testing.T) {
	t.Run("RandomPrefixed", func(t *testing.T) {
		t.Run("should have provided prefix", func(t *testing.T) {
			v, err := int160.RandomPrefixed("EX")
			require.NoError(t, err)
			require.Equal(t, "EX", string(v.Bytes()[:2]))
		})

		t.Run("have identically to original impl", func(t *testing.T) {
			var (
				pid [20]byte
			)
			o := copy(pid[:], "EX")
			n, err := rand.Read(pid[o:])
			require.NoError(t, err)
			require.Equal(t, 18, n)

			v, err := int160.RandomPrefixed("EX")
			require.NoError(t, err)
			require.Equal(t, "EX", v.ByteString()[:2])
			require.Equal(t, pid[:2], v.Bytes()[:2])
		})
	})

	t.Run("cmp", func(t *testing.T) {
		t.Run("identical should result in 0", func(t *testing.T) {
			i1 := int160.New("abc")
			i2 := int160.New("abc")

			require.Equal(t, 0, i1.Cmp(i2))
		})

		t.Run("i1 < i2 should be -1", func(t *testing.T) {
			i1 := int160.New("abc0")
			i2 := int160.New("abc1")

			require.Equal(t, -1, i1.Cmp(i2))
		})

		t.Run("i1 > i2 should be 1", func(t *testing.T) {
			i1 := int160.New("abc1")
			i2 := int160.New("abc0")

			require.Equal(t, 1, i1.Cmp(i2))
		})
	})
}

func TestNot(t *testing.T) {
	t.Run("zero bytes", func(t *testing.T) {
		input := int160.Zero()
		expected := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
		result := int160.Not(input)
		require.Equal(t, expected, result)
	})

	t.Run("all ones bytes", func(t *testing.T) {
		input := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
		expected := int160.Zero()
		result := int160.Not(input)
		require.Equal(t, expected, result)
	})

	t.Run("mixed bytes", func(t *testing.T) {
		input := int160.FromByteArray([20]byte{0xAA, 0x55, 0x00, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00})
		expected := int160.FromByteArray([20]byte{0x55, 0xAA, 0xFF, 0x00, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xFF})
		result := int160.Not(input)
		require.Equal(t, expected, result)
	})
}

func TestClosest(t *testing.T) {
	t.Run("single closest value", func(t *testing.T) {
		target := int160.Zero()
		v1 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01})
		v2 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05})
		v3 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10})

		result := int160.Closest(target, v1, v2, v3)
		require.Equal(t, v1, result)
	})

	t.Run("closest value is the smallest negative value", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50})

		v1 := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0})
		v2 := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80})
		v3 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51})

		result := int160.Closest(target, v1, v2, v3)
		require.Equal(t, v3, result)
	})

	t.Run("closest value is smaller than Not(target)", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
		v1 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01})
		v2 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
		result := int160.Closest(target, v1, v2)
		require.Equal(t, v2, result)
	})

	t.Run("empty values list returns Zero()", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44})
		result := int160.Closest(target)
		require.Equal(t, int160.Zero(), result)
	})

	t.Run("value equal to Not(target) returns Zero()", func(t *testing.T) {
		target := int160.Random()
		result := int160.Closest(target, int160.Not(target))
		require.Equal(t, int160.Zero(), result)
	})

	t.Run("closest value is the target always itself", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50})

		v1 := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0})
		v2 := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80})
		v3 := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51})

		result := int160.Closest(target, v1, v2, v3, target)
		require.Equal(t, target, result)
	})
}

func TestCmpTo(t *testing.T) {
	t.Run("a is closer to target", func(t *testing.T) {
		target := int160.Zero()
		a := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01})
		b := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05})

		result := int160.CmpTo(target, a, b)
		require.Equal(t, -1, result)
	})

	t.Run("b is closer to target", func(t *testing.T) {
		target := int160.Zero()
		a := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05})
		b := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01})

		result := int160.CmpTo(target, a, b)
		require.Equal(t, 1, result)
	})

	t.Run("a and b are equally distant from target but on opposite sides", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50})
		a := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51}) // Distance 1
		b := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F}) // Distance 1 (using XOR distance)

		require.Equal(t, -1, int160.CmpTo(target, a, b), "the node > target will be considered smaller")
		require.Equal(t, 1, int160.CmpTo(target, b, a), "the node > target will be considered smaller")
	})

	t.Run("a equals target and is closer", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA})
		a := target
		b := int160.FromByteArray([20]byte{0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB})

		result := int160.CmpTo(target, a, b)
		require.Equal(t, -1, result)
	})

	t.Run("b equals target and is closer", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA})
		a := int160.FromByteArray([20]byte{0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB})
		b := target

		result := int160.CmpTo(target, a, b)
		require.Equal(t, 1, result)
	})

	t.Run("target is zero, compare two non-zero values", func(t *testing.T) {
		target := int160.Zero()
		a := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10})
		b := int160.FromByteArray([20]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20})

		result := int160.CmpTo(target, a, b)
		require.Equal(t, -1, result)
	})

	t.Run("target is all ones, compare two values", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
		a := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE})
		b := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC})

		result := int160.CmpTo(target, a, b)
		require.Equal(t, -1, result)
	})

	t.Run("a and b are Not(target)", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA})
		notTarget := int160.Not(target)
		a := notTarget
		b := notTarget

		result := int160.CmpTo(target, a, b)
		require.Equal(t, 0, result)
	})

	t.Run("a and b are zero and target is all ones", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})
		a := int160.Zero()
		b := int160.Zero()

		result := int160.CmpTo(target, a, b)
		require.Equal(t, 0, result)
	})

	t.Run("a and b are identical but non-zero/non-all-ones", func(t *testing.T) {
		target := int160.FromByteArray([20]byte{0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55})
		a := int160.FromByteArray([20]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA})
		b := a

		result := int160.CmpTo(target, a, b)
		require.Equal(t, 0, result)
	})
}
